// Copyright (c) 2002-2010, Boyce Griffith
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
//    * Neither the name of New York University nor the names of its
//      contributors may be used to endorse or promote products derived from
//      this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// Config files

//#include <IBAMR_prefix_config.h>
//#include <IBTK_prefix_config.h> // these are only for debugging?
#include <SAMRAI_config.h>

// Headers for basic PETSc functions
#include <petscsys.h>

// Headers for basic SAMRAI objects
#include <BergerRigoutsos.h>
#include <CartesianGridGeometry.h>
#include <LoadBalancer.h>
#include <StandardTagAndInitialize.h>

// Headers for application-specific algorithm/data structure objects
#include "ibtk/LData.h"
#include "ibtk/LDataManager.h"
#include <ibamr/IBMethod.h>
#include <ibamr/IBStandardInitializer.h>
#include <ibamr/IBStandardForceGen.h>
#include <ibamr/IBLagrangianForceStrategySet.h>
#include <ibamr/INSCollocatedHierarchyIntegrator.h>
#include <ibamr/INSStaggeredHierarchyIntegrator.h>
#include <ibamr/INSStaggeredStochasticForcing.h>
#include <ibamr/RNG.h>
#include <ibamr/app_namespaces.h>
#include <ibtk/AppInitializer.h>
#include <ibtk/muParserCartGridFunction.h>
#include <ibtk/muParserRobinBcCoefs.h>


#include "IBBrownianBlobHierarchyIntegrator.h"

// Function prototypes
void
output_data(
    Pointer<PatchHierarchy<NDIM> > patch_hierarchy,
    Pointer<INSHierarchyIntegrator> navier_stokes_integrator,
    LDataManager* l_data_manager,
    const int iteration_num,
    const double loop_time,
    const int output_level,
    const string& data_dump_dirname);


/*!
 * \brief Function to compute the force generated by a WLC spring with a
 * non-zero resting length.
 */
inline double
WLC_spring_force(
    double R,
    const double* params,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{
    const double kBT = params[2];//   4.08672045e-9 in  um^2 kg/(s^2), 
    const double bk = params[0]; // in um, should be 0.106 um
    const double R_0 = params[1]; // 2.1 um
      
    return kBT/(2.0*bk)*((1.0/(pow(1.0 - R/R_0,2))) - 1.0 + 4.0*(R/R_0));

}// WLC_spring_force

inline double
WLC_spring_force_deriv(
    double R,
    const double* params,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{
    const double kbT = 4.08672045e-9; // um^2 kg/(s^2)
    const double bk = params[0]; // in um, should be 0.106 um
    const double R_0 = params[1]; // 2.1 um


    return (kbT/(2.0*bk))*((2.0/R_0)/(pow(1.0 - R/R_0,3)) + 4.0/R_0);
}// WLC_spring_force_deriv

/*!
 * \brief Function to compute the force generated by a linear spring with a
 * non-zero resting length.
 */
inline double
linear_spring_force(
    double R,
    const double* params,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{
    const double stf = params[0];
    const double rst = params[1];
    return stf*(R/rst - 1.0);
}// linear_spring_force

/*!
 * \brief Function to compute the force generated by a linear spring with a
 * non-zero resting length.
 */
inline double
linear_spring_force_deriv(
    double /*R*/,
    const double* params,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{
    const double stf = params[0];
    const double rst = params[1];
    return stf/rst;
}// linear_spring_force_deriv



/*!
 * \brief Function to compute the force generated by nonbonded interactions
 * through a temporary spring
 */
inline double
nonbonded_spring_force(
    double R,
    const double* /*params*/,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{
    
    double f;
    // parameters, hard coded for now.
    double sigma = 2.0;
    double ratio = sigma/R;
    double epsilon = 0.001;
    
    if (R < pow(2,(1.0/6.0))*sigma)
    {
        f = -24.0*epsilon*(2.0*pow(ratio,12) - pow(ratio,6))/R;
    }
    else
    {
        f = 0.0;
    }

    return f;
}// nonbonded_spring_force

/*!
 * \brief Function to compute the force generated by nonbonded interactions
 *  through a temporary spring.
 */

inline double
nonbonded_spring_force_deriv(
    double /*R*/,
    const double* /*params*/,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{
    cout << "WARNING: Using Force Derivative for nonbonded spring, which is incorrect." << std::endl;
    return 0.0;
}// nonbonded_spring_force_deriv


inline double
AODRLJ_spring_force(
    double R,
    const double* /*params*/,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{

    double f;
    // parameters, hard coded for now.
    double sigma = 3.2;
    double rColloid = 2.245*sigma; //DIAMETER OF THE COLLOID                           
    double rPolymer = 0.449*sigma; //DIAMETER OF THE POLYMER 
    double epsilon = 10.0;   //  depth of potential well
    float c = 1.78527832;   //58.5/sigma^3;  float prefactor = 0.590006 * temperature * pi;
    
    if(R>rColloid+rPolymer)
    {
        f=0;
    }
    else if (R<rColloid)
    {
        f = -c*(pow((rColloid+rPolymer),2) - pow(rColloid,2));
    }
    else  //r<Rcol+Rpol 
    {
        f = -c*(pow((rColloid+rPolymer),2) - pow(R,2));
    }
    
    f = f + 24.0*epsilon*pow(R/(2.0*sigma),-24)/R;

    return -1.0*f;
    
}// AODRLJ_spring_force

inline double
AODRLJ_spring_force_deriv(
    double /*R*/,
    const double* /*params*/,
    int /*lag_mastr_idx*/,
    int /*lag_slave_idx*/)
{

    cout << "WARNING: USING FORCE DERIVATIVE WHICH IS NOT CORRECT." << std::endl;
    return 0.0;
}// AODRLJ_spring_force_deriv


inline void
TruncLJ_nonbdd_force(
    double* D,
    const SAMRAI::tbox::Array<double> parameters,
    double* out_force)
{
    // truncated lennard jones potential for
    // nonbonded forces
    
    double R = 0.0;
    double sigma = parameters[0];
    double epsilon = parameters[1];
    double T_over_R = 0.0;

    for (int k = 0; k < NDIM; ++k)
    {
        R += pow(D[k],2);
    }

    R = sqrt(R);

    if(R < 2.0*(pow(sigma,1.0/6.0)))
    {
        T_over_R = 24.0*epsilon*(2.0*pow((sigma/R),12.0) - pow((sigma/R),6.0))/R;
    }
    else
    {
        T_over_R = 0.0;
    }

    for (int k = 0; k < NDIM; ++k)
    {
        out_force[k] = D[k]*T_over_R;
    }
    
    return;
}

inline void
Test_nonbdd_force(
    double* D,
    const SAMRAI::tbox::Array<double> parameters,
    double* out_force)
{
    // Test nonbonded forces
    for (int k = 0; k < NDIM; ++k)
    {
        out_force[k] = D[k]/100.0;
        cout << "out force component " << k << ": " << out_force[k] << std::endl;
    };
    cout << "parameters component " << 0 << ": " << parameters[0] << std::endl;
    cout << "parameters component " << 1 << ": " << parameters[1] << std::endl;
}

inline double
test_wall_force(double D, const SAMRAI::tbox::Array<double> params)
{

    cout << "force from wall is " << D/1000.0 << std::endl;
    cout << "parameter 0 is " << params[0] << std::endl;
    cout << "parameter 1 is " << params[1] << std::endl;
    return D/1000.0;

}

inline double
channel_nearwall_force(double D, const SAMRAI::tbox::Array<double> params)
{
    // params[0] = spring constant,
    // params[1] = cutoff range

    // quadtratic potential to push particles away from walls
    
    if (D < params[1])
    {
        return params[0]*abs(D - params[1]);
    }
    else
    {
        return 0.0;
    }

}


/*******************************************************************************
 * For each run, the input filename and restart information (if needed) must   *
 * be given on the command line.  For non-restarted case, command line is:     *
 *                                                                             *
 *    executable <input file name>                                             *
 *                                                                             *
 * For restarted run, command line is:                                         *
 *                                                                             *
 *    executable <input file name> <restart directory> <restart number>        *
 *                                                                             *
 *******************************************************************************/
int
main(
    int argc,
    char* argv[])
{
    // Initialize PETSc, MPI, and SAMRAI.
    PetscInitialize(&argc,&argv,NULL,NULL);
    SAMRAI_MPI::setCommunicator(PETSC_COMM_WORLD);
    SAMRAI_MPI::setCallAbortInSerialInsteadOfExit();
    SAMRAIManager::startup();

    {// cleanup dynamically allocated objects prior to shutdown

        // Parse command line options, set some standard options from the input
        // file, initialize the restart database (if this is a restarted run),
        // and enable file logging.
        Pointer<AppInitializer> app_initializer = new AppInitializer(argc, argv, "IB.log");
        Pointer<Database> input_db = app_initializer->getInputDatabase();

        // Get various standard options set in the input file.
        const bool dump_viz_data = app_initializer->dumpVizData();
        const int viz_dump_interval = app_initializer->getVizDumpInterval();
        const bool uses_visit = dump_viz_data && app_initializer->getVisItDataWriter();

        const bool is_from_restart = app_initializer->isFromRestart();
        const bool dump_restart_data = app_initializer->dumpRestartData();
        const int restart_dump_interval = app_initializer->getRestartDumpInterval();
        const string restart_dump_dirname = app_initializer->getRestartDumpDirectory();

        const bool dump_postproc_data = app_initializer->dumpPostProcessingData();
        const int postproc_data_dump_interval = app_initializer->getPostProcessingDataDumpInterval();
        const string postproc_data_dump_dirname = app_initializer->getPostProcessingDataDumpDirectory();
        if (dump_postproc_data && (postproc_data_dump_interval > 0) && !postproc_data_dump_dirname.empty())
        {
            Utilities::recursiveMkdir(postproc_data_dump_dirname);
        }

        // set defaults and switches
        double regrid_alpha = 0.5;   // regrid parameter default
        string spread_fcn = "IB_4";  // default interpolation and spreading function
        bool is_vel_normalized = false;  // variable for enforcing velocity normalization
        
        const bool dump_timer_data = app_initializer->dumpTimerData();
        const int timer_dump_interval = app_initializer->getTimerDumpInterval();

        // Create major algorithm and data objects that comprise the
        // application.  These objects are configured from the input database
        // and, if this is a restarted run, from the restart database.
        Pointer<INSStaggeredHierarchyIntegrator> navier_stokes_integrator;
        const string solver_type = app_initializer->getComponentDatabase("Main")->getStringWithDefault("solver_type", "STAGGERED");

        // use staggered solver with stochastic forces
        navier_stokes_integrator = new INSStaggeredHierarchyIntegrator(
                "INSStaggeredHierarchyIntegrator", app_initializer->getComponentDatabase("INSStaggeredHierarchyIntegrator"));

        // Set up ghost cell width and delta function for l_data_manager
        if(app_initializer->getComponentDatabase("IBHierarchyIntegrator")->keyExists("regrid_alpha"))
        {
            regrid_alpha = app_initializer->getComponentDatabase("IBHierarchyIntegrator")->getDouble("regrid_alpha");
        }

        // set min ghost width to 2.0 * regrid_alpha,
        // the program guarantees that a particle will never
        // move more than 2*regrid_alpha*h  between regrids
        SAMRAI::hier::IntVector<NDIM> gcw;
        double interaction = app_initializer->getComponentDatabase("IBHierarchyIntegrator")->getDoubleWithDefault("interaction_radius",0.0);
        
        for (int k = 0; k < NDIM; ++k)
        {
            gcw[k] = 2.0*regrid_alpha  + interaction;
        }
        if(app_initializer->getComponentDatabase("IBMethod")->keyExists("delta_fcn"))
        {
            spread_fcn =
                app_initializer->getComponentDatabase("IBMethod")->getString("delta_fcn");
        }

        // Initialize l_data_manager
        LDataManager* l_data_manager = LDataManager::getManager("IBMethod::LDataManager",
                                                                spread_fcn,
                                                                spread_fcn,
                                                                gcw,
                                                                false);
        Pointer<IBMethod> ib_method_ops = new IBMethod(
            "IBMethod", app_initializer->getComponentDatabase("IBMethod"));
        Pointer<CartesianGridGeometry<NDIM> > grid_geometry = new CartesianGridGeometry<NDIM>(
            "CartesianGeometry", app_initializer->getComponentDatabase("CartesianGeometry"));
        Pointer<IBBrownianBlobHierarchyIntegrator> time_integrator =
            new IBBrownianBlobHierarchyIntegrator("IBBrownianBlobHierarchyIntegrator",
                app_initializer->getComponentDatabase("IBHierarchyIntegrator"),
                ib_method_ops, navier_stokes_integrator,grid_geometry);
        Pointer<PatchHierarchy<NDIM> > patch_hierarchy = new PatchHierarchy<NDIM>(
            "PatchHierarchy", grid_geometry);
        Pointer<StandardTagAndInitialize<NDIM> > error_detector =
            new StandardTagAndInitialize<NDIM>(
                "StandardTagAndInitialize", time_integrator, app_initializer->getComponentDatabase("StandardTagAndInitialize"));
        Pointer<BergerRigoutsos<NDIM> > box_generator = new BergerRigoutsos<NDIM>();
        Pointer<LoadBalancer<NDIM> > load_balancer = new LoadBalancer<NDIM>(
            "LoadBalancer", app_initializer->getComponentDatabase("LoadBalancer"));
        Pointer<GriddingAlgorithm<NDIM> > gridding_algorithm = new GriddingAlgorithm<NDIM>(
            "GriddingAlgorithm", app_initializer->getComponentDatabase("GriddingAlgorithm"), error_detector, box_generator, load_balancer);

        // Configure the IB solver.
        Pointer<IBStandardInitializer> ib_initializer = new IBStandardInitializer(
            "IBStandardInitializer", app_initializer->getComponentDatabase("IBStandardInitializer"));
        ib_method_ops->registerLInitStrategy(ib_initializer);

        // register IB spring forces
        Pointer<IBStandardForceGen> ib_force_fcn = new IBStandardForceGen();
        ib_force_fcn->registerSpringForceFunction(0,&linear_spring_force,&linear_spring_force_deriv);
        ib_force_fcn->registerSpringForceFunction(1,&WLC_spring_force,&WLC_spring_force_deriv);
        ib_force_fcn->registerSpringForceFunction(3,&AODRLJ_spring_force,&AODRLJ_spring_force_deriv);

        //create strategy set with springs, walls, and nonbonded forces
        std::vector<SAMRAI::tbox::Pointer<IBLagrangianForceStrategy> > ib_force_strat_vec;
        ib_force_strat_vec.push_back(ib_force_fcn);

        if(input_db->keyExists("NonbondedForceEvaluator"))
        {
            // create nonbonded force evaluator
            Pointer<NonbondedForceEvaluator> ib_nonbonded_force_fcn = new NonbondedForceEvaluator(input_db->getDatabase("NonbondedForceEvaluator"),grid_geometry);
            // register force function for nonbonded forces
            ib_nonbonded_force_fcn->registerForceFcnPtr(&TruncLJ_nonbdd_force);
            // add to force strategy
            ib_force_strat_vec.push_back(ib_nonbonded_force_fcn);
        }
        if(input_db->keyExists("WallForceEvaluator"))
        {
            //create wall force evaluator
            Pointer<WallForceEvaluator> ib_wall_force_fcn = new WallForceEvaluator(input_db->getDatabase("WallForceEvaluator"),grid_geometry);
            //register force for walls
            ib_wall_force_fcn->registerWallForceFcn(&channel_nearwall_force);
            // add walls to force strategy
            ib_force_strat_vec.push_back(ib_wall_force_fcn);
        }


        Pointer<IBLagrangianForceStrategySet> ib_force_strat_set = new IBLagrangianForceStrategySet(ib_force_strat_vec.begin(),ib_force_strat_vec.end());
        
        ib_method_ops->registerIBLagrangianForceFunction(ib_force_strat_set);
        time_integrator->registerIBLagrangianForceFunction(ib_force_strat_set);
        
        // Create Eulerian initial condition specification objects.
        if (input_db->keyExists("VelocityInitialConditions"))
        {
            Pointer<CartGridFunction> u_init = new muParserCartGridFunction(
                "u_init", app_initializer->getComponentDatabase("VelocityInitialConditions"), grid_geometry);
            navier_stokes_integrator->registerVelocityInitialConditions(u_init);
        }

        if (input_db->keyExists("PressureInitialConditions"))
        {
            Pointer<CartGridFunction> p_init = new muParserCartGridFunction(
                "p_init", app_initializer->getComponentDatabase("PressureInitialConditions"), grid_geometry);
            navier_stokes_integrator->registerPressureInitialConditions(p_init);
        }

        // Create Eulerian boundary condition specification objects (when necessary).
        const IntVector<NDIM>& periodic_shift = grid_geometry->getPeriodicShift();
        vector<RobinBcCoefStrategy<NDIM>*> u_bc_coefs(NDIM);
        if (periodic_shift.min() > 0)
        {
            for (unsigned int d = 0; d < NDIM; ++d)
            {
                u_bc_coefs[d] = NULL;
            }
        }
        else
        {
            for (unsigned int d = 0; d < NDIM; ++d)
            {
                ostringstream bc_coefs_name_stream;
                bc_coefs_name_stream << "u_bc_coefs_" << d;
                const string bc_coefs_name = bc_coefs_name_stream.str();

                ostringstream bc_coefs_db_name_stream;
                bc_coefs_db_name_stream << "VelocityBcCoefs_" << d;
                const string bc_coefs_db_name = bc_coefs_db_name_stream.str();

                u_bc_coefs[d] = new muParserRobinBcCoefs(
                    bc_coefs_name, app_initializer->getComponentDatabase(bc_coefs_db_name), grid_geometry);
            }
            navier_stokes_integrator->registerPhysicalBoundaryConditions(u_bc_coefs);
        }
	time_integrator->setVelocityBC(&u_bc_coefs);
	        
        // Create stochastic forcing function specification object
        Pointer<INSStaggeredStochasticForcing> f_stoch_fcn = new INSStaggeredStochasticForcing("INSStaggeredStochasticForcing", app_initializer->getComponentDatabase("INSStaggeredStochasticForcing"), navier_stokes_integrator);
        time_integrator->registerBodyForceFunction(f_stoch_fcn);

        
        //////////////////////////////////////
        // check inputs for consistency:
        ////////////////////////////////////

        // check to make sure velocity is normalized
        if (app_initializer->getComponentDatabase("INSStaggeredHierarchyIntegrator")->keyExists("normalize_velocity"))
        {
                
            is_vel_normalized = app_initializer->getComponentDatabase("INSStaggeredHierarchyIntegrator")->getBool("normalize_velocity");
        }

        // Velocity must be normalized if all BCs are periodic, otherwise it must not be.
        // necessary for rho = 0 and periodic BCs only
        if (!is_vel_normalized)
        {
            
            if (periodic_shift.min() > 0)
            {
                TBOX_ERROR("NORMALIZE_VELOCITY must be TRUE with all periodic boundaries.");
            }
            
        }
        else
        {
            if (!(periodic_shift.min() > 0))
            {
                TBOX_ERROR("When boundaries are not all periodic, NORMALIZE_VELOCITY must be FALSE.");
            }
        }
        
        // Seed the random number generator.
        int seed = 0;
        if (input_db->keyExists("SEED"))
        {
            seed = input_db->getInteger("SEED");
        }
        else
        {
            TBOX_ERROR("Key data `seed' not found in input.");
        }
        RNG::parallel_seed(seed);

        // get temperature kT
        double kT = 1.0;
        if (input_db->keyExists("kT"))
        {
            kT = input_db->getDouble("kT");
            time_integrator->SetkT(kT);
        }
        else
        {
            TBOX_ERROR("Key data `kT' not found in input.");
        }

        // get rfdelta
        double rfdelta = 0.00001;
        if (input_db->keyExists("RFDELTA"))
        {
            rfdelta = input_db->getDouble("RFDELTA");
        }
        time_integrator->SetRfdelta(rfdelta,grid_geometry);

        // Get dynamics
        string dynamics = "OVERDAMPED";
        if (input_db->keyExists("DYNAMICS"))
        {
            dynamics = input_db->getString("DYNAMICS");
            time_integrator->SetDynamics(dynamics);
        }
        else
        {
            TBOX_ERROR("Key data `DYNAMICS' not found in input.");
        }
        
        // We are primarily interested in the Lagrangian data so we can skip writing Eulerian data:
        int output_level = 2; // -1=none, 0=txt, 1=silo+txt, 2=visit+silo+txt, 3=visit+SAMRAI+silo+txt, >3=verbose
        if (input_db->keyExists("OUTPUT_LEVEL"))
        {
            output_level = input_db->getInteger("OUTPUT_LEVEL");
        }

        // Create Eulerian body force function specification objects.
        if (input_db->keyExists("ForcingFunction"))
        {
            Pointer<CartGridFunction> f_fcn = new muParserCartGridFunction(
                "f_fcn", app_initializer->getComponentDatabase("ForcingFunction"), grid_geometry);
            time_integrator->registerBodyForceFunction(f_fcn);
        }

        // Set up visualization plot file writers.
        Pointer<VisItDataWriter<NDIM> > visit_data_writer = app_initializer->getVisItDataWriter();
        Pointer<LSiloDataWriter> silo_data_writer = app_initializer->getLSiloDataWriter();
        if (uses_visit)
        {
            ib_initializer->registerLSiloDataWriter(silo_data_writer);
            time_integrator->registerVisItDataWriter(visit_data_writer);
            ib_method_ops->registerLSiloDataWriter(silo_data_writer);
        }

        // Initialize hierarchy configuration and data on all patches.	
        time_integrator->initializePatchHierarchy(patch_hierarchy, gridding_algorithm);

        // Deallocate initialization objects.
        ib_method_ops->freeLInitStrategy();
        ib_initializer.setNull();
        app_initializer.setNull();

        // Print the input database contents to the log file.
        plog << "Input database:\n";
        input_db->printClassData(plog);

        // Write restart data before starting main time integration loop.
        if (dump_restart_data && !is_from_restart)
        {
            pout << "\nWriting restart files...\n\n";
            RestartManager::getManager()->writeRestartFile(restart_dump_dirname, 0);
        }

        // Write out initial visualization data.
        int iteration_num = time_integrator->getIntegratorStep();
        double loop_time = time_integrator->getIntegratorTime();
        if (dump_viz_data && uses_visit)
        {
            pout << "\n\nWriting visualization files...\n\n";
            time_integrator->setupPlotData();
            visit_data_writer->writePlotData(patch_hierarchy, iteration_num, loop_time);
            silo_data_writer->writePlotData(iteration_num, loop_time);
        }

        // Main time step loop.
        double loop_time_end = time_integrator->getEndTime();
        double dt = 0.0;
        while (!MathUtilities<double>::equalEps(loop_time,loop_time_end) &&
               time_integrator->stepsRemaining())
        {
            iteration_num = time_integrator->getIntegratorStep();
            loop_time = time_integrator->getIntegratorTime();

//            if(iteration_num % 100 == 0)
//            {
//                pout <<                                                    "\n";
//                pout << "+++++++++++++++++++++++++++++++++++++++++++++++++++\n";
//                pout << "At beginning of timestep # " <<  iteration_num << "\n";
//                pout << "Simulation time is " << loop_time              << "\n";
//            }

            dt = time_integrator->getMaximumTimeStepSize();
            time_integrator->advanceHierarchy(dt);
            loop_time += dt;

//            if(iteration_num % 100 == 0)
//            {
//                pout <<                                                    "\n";
//                pout << "At end       of timestep # " <<  iteration_num << "\n";
//                pout << "Simulation time is " << loop_time              << "\n";
//                pout << "+++++++++++++++++++++++++++++++++++++++++++++++++++\n";
//                pout <<                                                    "\n";
//            }


            // At specified intervals, write visualization and restart files,
            // print out timer data, and store hierarchy data for post
            // processing.
            iteration_num += 1;
            const bool last_step = !time_integrator->stepsRemaining();
            if (dump_viz_data && uses_visit && (iteration_num%viz_dump_interval == 0 || last_step))
            {
                pout << "\nWriting visualization files...\n\n";
                time_integrator->setupPlotData();
                visit_data_writer->writePlotData(patch_hierarchy, iteration_num, loop_time);
                silo_data_writer->writePlotData(iteration_num, loop_time);
            }
            if (dump_restart_data && (iteration_num%restart_dump_interval == 0 || last_step))
            {
                pout << "\nWriting restart files...\n\n";
                RestartManager::getManager()->writeRestartFile(restart_dump_dirname, iteration_num);
            }
            if (dump_timer_data && (iteration_num%timer_dump_interval == 0 || last_step))
            {
                pout << "\nWriting timer data...\n\n";
                TimerManager::getManager()->print(plog);
            }
            if (dump_postproc_data && (iteration_num%postproc_data_dump_interval == 0 || last_step))
            {
                output_data(patch_hierarchy,
                            navier_stokes_integrator, ib_method_ops->getLDataManager(),
                            iteration_num, loop_time, output_level, postproc_data_dump_dirname);
            }
        }

        // Cleanup Eulerian boundary condition specification objects (when
        // necessary).
        for (unsigned int d = 0; d < NDIM; ++d) delete u_bc_coefs[d];
        (void) l_data_manager; // silence unused warning.
    }// cleanup dynamically allocated objects prior to shutdown

    SAMRAIManager::shutdown();
    PetscFinalize();
    return 0;
}// main

void
output_data(
    Pointer<PatchHierarchy<NDIM> > patch_hierarchy,
    Pointer<INSHierarchyIntegrator> navier_stokes_integrator,
    LDataManager* l_data_manager,
    const int iteration_num,
    const double loop_time,
    const int output_level,
    const string& data_dump_dirname)
{
    if (output_level >= 0)
    {
        pout << "\nWriting output files at timestep # " <<  iteration_num << " t=" << loop_time << "\n";
    }
    string file_name = data_dump_dirname + "/" + "hier_data.";
    char temp_buf[128];
    sprintf(temp_buf, "%05d.samrai.%05d", iteration_num, SAMRAI_MPI::getRank());
    file_name += temp_buf;

    // Write Cartesian data.
    if (output_level >= 3)
    {
        Pointer<HDFDatabase> hier_db = new HDFDatabase("hier_db");
        hier_db->create(file_name);
        VariableDatabase<NDIM>* var_db = VariableDatabase<NDIM>::getDatabase();
        ComponentSelector hier_data;
        hier_data.setFlag(var_db->mapVariableAndContextToIndex(navier_stokes_integrator->getVelocityVariable(), navier_stokes_integrator->getCurrentContext()));
        hier_data.setFlag(var_db->mapVariableAndContextToIndex(navier_stokes_integrator->getPressureVariable(), navier_stokes_integrator->getCurrentContext()));
        patch_hierarchy->putToDatabase(hier_db->putDatabase("PatchHierarchy"), hier_data);
        hier_db->putDouble("loop_time", loop_time);
        hier_db->putInteger("iteration_num", iteration_num);
        hier_db->close();
    }

    // Write Lagrangian data.
    if (output_level >= 0)
    {
        const int finest_hier_level = patch_hierarchy->getFinestLevelNumber();
        Pointer<LData> X_data = l_data_manager->getLData("X", finest_hier_level);
        Vec X_petsc_vec = X_data->getVec();
        Vec X_lag_vec;
        Vec X_real_petsc_vec;
        PetscErrorCode ierr;
        VecDuplicate(X_petsc_vec, &X_lag_vec);
        VecDuplicate(X_petsc_vec,&X_real_petsc_vec);
        ierr = VecCopy(X_petsc_vec,X_real_petsc_vec); IBTK_CHKERRQ(ierr);
        PetscScalar *outposition;

        VecGetArray(X_real_petsc_vec,&outposition);

        // output virtual location, the "real" location in a periodic setting.
        const Pointer<LMesh> mesh = l_data_manager->getLMesh(finest_hier_level);
        const std::vector<LNode*>& local_nodes = mesh->getLocalNodes();
        for (std::vector<LNode*>::const_iterator cit = local_nodes.begin(); cit != local_nodes.end(); ++cit)
        {
        
            LNode* const node_idx = *cit;
            int local_idx = node_idx->getLocalPETScIndex();
            const Vector& periodic_disp = node_idx->getPeriodicDisplacement();
            for (unsigned int d = 0; d < NDIM; ++d)
            {
                outposition[local_idx*NDIM + d] = outposition[local_idx*NDIM + d] + periodic_disp[d];
            }
        }
        VecRestoreArray(X_real_petsc_vec,&outposition);
        l_data_manager->scatterPETScToLagrangian(X_real_petsc_vec, X_lag_vec, finest_hier_level);
        file_name = data_dump_dirname + "/" + "X.";
        sprintf(temp_buf, "%05d", iteration_num);
        file_name += temp_buf;
        PetscViewer viewer;
        PetscViewerASCIIOpen(PETSC_COMM_WORLD, file_name.c_str(), &viewer);
        VecView(X_lag_vec, viewer);
        PetscViewerDestroy(&viewer);
        VecDestroy(&X_lag_vec);
    }
    return;
}// output_data


